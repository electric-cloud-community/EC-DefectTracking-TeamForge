package TeamForge::FileStorageApp;

# Modifed by Dan Speers of Collabnet for the perlsdk kit for TeamForge
# -- generated by SOAP::Lite (v0.712) for Perl -- soaplite.com -- Copyright (C) 2000-2001 Paul Kulchenko --
# -- generated from https://forge.collab.net/ce-soap50/services/FileStorageApp?wsdl [Mon Nov 15 16:37:42 2010]

=head1 NAME

TeamForge::FileStorageApp - Collabnet TeamForge API

=head1 METHODS

=over 4

=item downloadFile()


=over

=item Arguments

      sessionId             => soapenc:string
      fileId                => soapenc:string


Returns File as SOAP attachment.

Since 4.1

=back



Downloads file as SOAP attachment.



----

=item downloadFileDirect()


=over

=item Arguments

      sessionId             => soapenc:string
      containerId           => soapenc:string
      rawFileId             => soapenc:string


Returns File as SOAP attachment.

Since 4.4SP1

=back



Downloads file Direct as SOAP attachment. This doesnt assume that the
file to be downloaded is stored in the session. This can only be used
for Wiki or Tracker (Because those are the two for which we check
permissions)



----

=item uploadFile()


=over

=item Arguments

      sessionId             => soapenc:string
      file                  => apachesoap:DataHandler


Returns File object id.

Since 4.1

=back



Provides SOAP web service for uploading/downloading files. Uploaded
files are assigned a "tempoary session-specific key" which must be used
within the SOAP session to create a document/FRS file/etc. Otherwise,
the uploaded file is simply discarded. This service provides support
for uploading/downloading files as attachments. Clients which are
unable to use SOAP file attachments for uploading files, can use
"SimpleFileStorageApp" service for uploading files in memory.

B<Change History>

I<Version 4.4>: No changes.

Uploads a file as SOAP attachment. The returned file id can be used to
associate the file with a document, frs file, etc. Note that a file can
ONLY be associated with a single document or an frs file.



----

=back

=cut

my %methods = (
  uploadFile => {
    endpoint => 'http://localhost:8080/ce-soap50/services/FileStorageApp',
    soapaction => '',
    uri => '',
    parameters => [
      SOAP::Data->new(name => 'sessionId', type => 'soapenc:string', attr => {}),
      SOAP::Data->new(name => 'file', type => 'apachesoap:DataHandler', attr => {}),
    ],
  },
  downloadFile => {
    endpoint => 'http://localhost:8080/ce-soap50/services/FileStorageApp',
    soapaction => '',
    uri => '',
    parameters => [
      SOAP::Data->new(name => 'sessionId', type => 'soapenc:string', attr => {}),
      SOAP::Data->new(name => 'fileId', type => 'soapenc:string', attr => {}),
    ],
  },
  downloadFileDirect => {
    endpoint => 'http://localhost:8080/ce-soap50/services/FileStorageApp',
    soapaction => '',
    uri => '',
    parameters => [
      SOAP::Data->new(name => 'sessionId', type => 'soapenc:string', attr => {}),
      SOAP::Data->new(name => 'containerId', type => 'soapenc:string', attr => {}),
      SOAP::Data->new(name => 'rawFileId', type => 'soapenc:string', attr => {}),
    ],
  },
);

use SOAP::Lite;
use Exporter;
use Carp ();
use URI;

use vars qw(@ISA $AUTOLOAD @EXPORT_OK %EXPORT_TAGS);
@ISA = qw(Exporter SOAP::Lite);
@EXPORT_OK = (keys %methods);
%EXPORT_TAGS = ('all' => [@EXPORT_OK]);

no strict 'refs';
for my $method (@EXPORT_OK) {
  my %method = %{$methods{$method}};
  *$method = sub {
    my $self = UNIVERSAL::isa($_[0] => __PACKAGE__) 
      ? ref $_[0] ? shift # OBJECT
                  # CLASS, either get self or create new and assign to self
                  : (shift->self || __PACKAGE__->self(__PACKAGE__->new))
      # function call, either get self or create new and assign to self
      : (__PACKAGE__->self || __PACKAGE__->self(__PACKAGE__->new));
    my $endpoint;
    eval {
    	$endpoint = $self->transport->endpoint;
    };
    if ( $endpoint ) {
    	$endpoint = host($method{endpoint},$endpoint);
    } else {
    	$endpoint = $method{endpoint};
    }

    my @templates = @{$method{parameters}};
    my @args;
    for ( my $ct = 0; $ct <= $#_; $ct++ ) {
	my $val  = $_[$ct];
	my $type = $templates[$ct]->type;

	if ( ref($val) && ref($val) ne 'HASH' && ref($val) ne 'ARRAY' ) {
	    $val->prepare()                           if ( $type =~ /^tns1:.*SoapDO$/ );
	    $val = $val->simpleHash                   if ( $type eq 'tns1:SoapFilter' );
	    $val = $val->prepare                      if ( $type eq 'impl:ArrayOf_tns1_SoapFilter' );
	} else {
	    $val = SOAP::Utils::encode_data( $val )   if ( $type =~ /^(xsd|soapenc):string$/ );
	}

	push @args, $templates[$ct]->value( $val );

    }
    $self->proxy($endpoint || Carp::croak "No server address (proxy) specified") unless $self->proxy;
    my $som = $self
      -> endpoint($endpoint)
      -> uri($method{uri})
      -> readable(1)
      -> on_action(sub{qq!"$method{soapaction}"!})
      -> call(SOAP::Data->name('namesp2:'.$method)->attr({'xmlns:namesp2' => 'http://schema.vasoftware.com/sf/soap/service',
							  'xmlns:tns1' => 'http://schema.vasoftware.com/sf/soap/type'}) => 
	      @args);
	      #map {@templates ? shift(@templates)->value($_) : $_} @_); 

    UNIVERSAL::isa($som => 'SOAP::SOM') ? wantarray ? $som->paramsall : $som->result 
                                        : $som;
  }
}

sub AUTOLOAD {
  my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::') + 2);
  return if $method eq 'DESTROY';

  die "Unrecognized method '$method'. List of available method(s): @EXPORT_OK\n";
}

sub host {
	my $target = new URI shift;   # This is where the WSDL wants to go.
	my $proxy  = new URI shift;	  # This is where the object was instanciated to go.
	
	$proxy->path( $target->path );
	
	return $proxy->as_string;
	
}

sub describe {

    my $self   = shift;
    my $method = shift;

    if ( exists( $methods{ $method } )) {
	return $methods{ $method }->{ parameters };
    }
    return undef;

}

sub methods {
    my $self = shift;
    return \%methods;
}

1;
